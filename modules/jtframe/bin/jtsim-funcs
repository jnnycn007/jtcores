make_verilator_command() {
	echo "${VERILATOR_PATH}verilator -I$CORES/$SYSNAME/hdl"\
"       -I$JTFRAME/hdl/inc "\
"       -I$MODULES/jtkcpu/hdl -I$MODULES/jt900h/hdl "\
"       --timescale 1ps/1ps "\
"       $JTFRAME/hdl/ver/game_test.v $JTFRAME/hdl/video/jtframe_lfbuf*.v $JTFRAME/hdl/ver/psram128.v $SIMARGS "\
"       -Wno-TIMESCALEMOD --timescale-override 1ns/1ps -Wno-fatal "\
"       -o sim "\
"       $EXTRA $TRACE --prefix UUT --assert "\
"       --cc test.cpp --exe $SIMULATOR_EXTRA $COV "\
"       -Wwarn-UNDRIVEN --waiver-output waiver $GAME_VLT $VERILATOR_SAFE "
}

is_lint_on() {
	echo "$EXTRA" | grep lint-only
}

compile_verilator_sim() {
    # boost C++ optimization without affecting other settings
    if [ ! -z "$FAST" ]; then export CPPFLAGS=`echo "$CPPFLAGS" | sed s/-O1/-O3/`; fi
    if ! make $MAKEJOBS -C obj_dir -f UUT.mk sim > make.log; then
        cat make.log
        exit $?
    fi
}

prepare_fst_pipe() {
	rm -f test.vcd
    if [[ -n "$DUMP" && -z "$SHOWCMD" ]]; then
        if which vcd2fst > /dev/null; then
            mkfifo test.vcd
            vcd2fst -p test.vcd test.fst&
        fi
    fi
}

run_verilator_sim() {
	$SHOWCMD obj_dir/sim $TRACE -time $SIM_MS || echo "Verilator sim exit code $?"
}

clean_fst_pipe() {
	rm -f test.vcd
}

run_coverage() {
    mkdir -p cov
    verilator_coverage --annotate cov logs/coverage.dat
}

convert_raw2wav() {
	if [ -e sound.raw ]; then
	    $JTUTIL/bin/raw2wav $SAMPLING_RATE < sound.raw
	    rm -f sound.raw
	fi
}

check_shasum() {
	if [ ! -z "$SETNAME" ]; then
	    if [ ! -z "$SHAUP" ]; then
	        shasum frame*jpg > ../$SETNAME.sha;
	    elif [ -e ../$SETNAME.sha ]; then
	        if shasum --check ../$SETNAME.sha; then echo PASS; else echo FAIL; fi
	    fi
	fi
}

count_frame_images() {
	ls frames/frame*jpg 2>/dev/null | wc -l
}

make_mpeg() {
    if [ -z "$FRAMERATE" ]; then
        FRAMERATE=30
        echo "Define and export FRAMERATE"
        if has_macro JTFRAME_SIM_VIDEO; then
            FRAMERATE=60;
        elif [ $(ls frames/frame*jpg 2>/dev/null | wc -l ) -gt 2000 ]; then
            echo "Large number of frames... maybe enable JTFRAME_SIM_VIDEO to create a full video"
        fi
    fi
    if [[ "$VIDEO_DUMP" = TRUE ]]; then
        ffmpeg -y -framerate $FRAMERATE \
        -pattern_type glob -i frames/'frame_*.jpg' \
        -i test.wav -c:a aac -c:v libx264 -vf "scale=iw*3:ih*3" \
        -pix_fmt yuv420p test.mp4 > /dev/null 2>&1
    fi
}

convert_channel_raw2wav() {
	shopt -s nullglob
	CHRAW=(ch?.raw)
	shopt -u nullglob
	for i in "${CHRAW[@]}"; do
	    if [ $(od -An -tx1 -v $i | grep -v ' 00 ' | wc -l) -eq 0 ]; then
	        echo "$i is empty, deleting it" > /dev/null
	    else
	        ffmpeg -y -f s16le -ar 192000 -ac 2 -i $i ${i%.raw}.wav > /dev/null 2>&1 || continue
	    fi
	    rm -f $i
	done
}

copy_scene_frame() {
    SCNNUM=$(basename $(dirname $SCENE))
    set -v
    mv `ls frames/frame_*.jpg | tail -n 1` `dirname $SCENE`/$SCNNUM.jpg
    set +v
}

display_scene_frame() {
	last_frame_image=`ls frames/frame_*.jpg | tail -n 1`
	eom $last_frame_image
}
